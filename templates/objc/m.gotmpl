{{define "objc/m"}}// Generated by github.com/hypermusk/hypermusk
// DO NOT EDIT
{{$pkgName := .Name | title}}
{{$apiprefix := .Prefix}}
#import "{{.Name}}.h"

static {{$apiprefix}}{{.Name | title}} * _{{.Name}};
static NSDateFormatter * _dateFormatter;

@implementation {{$apiprefix}}{{.Name | title}} : NSObject
+ ({{$apiprefix}}{{.Name | title}} *) get {
	if(!_{{.Name}}) {
		_{{.Name}} = [[{{$apiprefix}}{{.Name | title}} alloc] init];
		if ([_qortexapi RequestTimeoutInterval] == 0) {
			[_qortexapi setRequestTimeoutInterval:10];
		}
	}
	return _{{.Name}};
}

+ (NSDateFormatter *) dateFormatter {
	if(!_dateFormatter) {
		_dateFormatter = [[NSDateFormatter alloc] init];
		[_dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZ"];
	}
	return _dateFormatter;
}

+ (NSDate *) dateFromString:(NSString *)dateString {
	if(!dateString) {
		return nil;
	}

	NSError *error;
	NSRegularExpression *regexp = [NSRegularExpression regularExpressionWithPattern:@"\\.[0-9]*" options:0 error:&error];
	NSAssert(!error, @"Error in regexp");

	NSRange range = NSMakeRange(0, [dateString length]);
	dateString = [regexp stringByReplacingMatchesInString:dateString options:0 range:range withTemplate:@""];

	NSDate *date;
	[[{{$apiprefix}}{{.Name | title}} dateFormatter] getObjectValue:&date forString:dateString range:nil error:&error];
	if(error) {
		if ([[{{$apiprefix}}{{.Name | title}} get] Verbose]) NSLog(@"Error formatting date %@: %@ (%@)", dateString, [error localizedDescription], error);
		return nil;
	}
	return date;
}

+ (NSString *) stringFromDate:(NSDate *) date {
	if(!date) {
		return nil;
	}
	NSString * dateString = [[{{$apiprefix}}{{.Name | title}} dateFormatter] stringFromDate:date];
	dateString = [[[dateString substringToIndex:(dateString.length - 3)] stringByAppendingString:@":"] stringByAppendingString:[dateString substringFromIndex:(dateString.length - 2)]];
	return dateString;
}

+ (NSDictionary *) request:(NSURL*)url req:(NSDictionary *)req error:(NSError **)error {
	{{$apiprefix}}{{$pkgName}} * _api = [{{$apiprefix}}{{$pkgName}} get];
	NSMutableURLRequest *httpRequest = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:[_api RequestTimeoutInterval]];

	[httpRequest setHTTPMethod:@"POST"];
	[httpRequest setValue:@"application/json;charset=utf-8" forHTTPHeaderField:@"Content-Type"];
	NSData *requestBody = [NSJSONSerialization dataWithJSONObject:req options:NSJSONWritingPrettyPrinted error:error];
	if([_api Verbose]) {
		NSLog(@"Request: %@", [NSString stringWithUTF8String:[requestBody bytes]]);
	}
	[httpRequest setHTTPBody:requestBody];
	if(*error != nil) {
		return nil;
	}
	NSURLResponse  *response = nil;
	NSData *returnData = [NSURLConnection sendSynchronousRequest:httpRequest returningResponse:&response error:error];
	if(*error != nil || returnData == nil) {
		return nil;
	}
	if([_api Verbose]) {
		NSLog(@"Response: %@", [NSString stringWithUTF8String:[returnData bytes]]);
	}
	return [NSJSONSerialization JSONObjectWithData:returnData options:NSJSONReadingAllowFragments error:error];
}

+ (void)request:(NSURL*)url
	 parameters:(NSDictionary *)parameters
completionHandler:(void (^)(NSDictionary *results, NSError *error))completionHandler {
	__block NSError *error = nil;
	NSOperationQueue *queue = [[NSOperationQueue alloc] init];

	NSMutableURLRequest *httpRequest = [NSMutableURLRequest requestWithURL:url];
	[httpRequest setHTTPMethod:@"POST"];
	[httpRequest setValue:@"application/json;charset=utf-8" forHTTPHeaderField:@"Content-Type"];
	QXQortexapi * _api = [QXQortexapi get];

	NSData *requestBody = [NSJSONSerialization dataWithJSONObject:parameters options:NSJSONWritingPrettyPrinted error:&error];
	if([_api Verbose]) {
		NSLog(@"Request: %@", [NSString stringWithUTF8String:[requestBody bytes]]);
	}
	[httpRequest setHTTPBody:requestBody];

	[NSURLConnection sendAsynchronousRequest:httpRequest
					   queue:queue
			       completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
						   if([_api Verbose]) {
							   NSLog(@"Response: %@", [NSString stringWithUTF8String:[data bytes]]);
							   NSLog(@"Connection Error: %@", connectionError);
						   }

						   if (completionHandler) {
							   NSDictionary *results = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&error];

								dispatch_async(dispatch_get_main_queue(), ^{
									completionHandler(results, error);
								});
						   }
						}];
}

+ (NSError *)errorWithDictionary:(NSDictionary *)dict {
	if (![dict isKindOfClass:[NSDictionary class]]) {
		return nil;
	}
	if ([[dict allKeys] count] == 0) {
		return nil;
	}
	NSMutableDictionary *userInfo = [NSMutableDictionary alloc];
	id reason = [dict valueForKey:@"Reason"];
	if ([reason isKindOfClass:[NSDictionary class]]) {
		userInfo = [userInfo initWithDictionary:reason];
	} else {
		userInfo = [userInfo init];
	}
	[userInfo setObject:[dict valueForKey:@"Message"] forKey:NSLocalizedDescriptionKey];

	NSString *code = [dict valueForKey:@"Code"];
	NSNumberFormatter *f = [[NSNumberFormatter alloc] init];
	[f setNumberStyle:NSNumberFormatterDecimalStyle];
	NSNumber *codeNumber = [f numberFromString:code];
	NSInteger intCode = -1;
	if (codeNumber != nil) {
		intCode = [codeNumber integerValue];
	}
	NSError *err = [NSError errorWithDomain:@"{{$pkgName}}Error" code:intCode userInfo:userInfo];
	return err;
}

@end

{{range .DataObjects}}{{$do := .}}
// --- {{.Name}} ---
@implementation {{$apiprefix}}{{.Name}}
{{template "objc/properties_m" $do.Fields}}
@end
{{end}}

// === Interfaces ===

{{range .Interfaces}}{{$interface := .}}
{{range .Methods}}{{if .ConstructorForInterface}}{{else}}{{$method := .}}
// --- {{$apiprefix}}{{.Name}}Params ---
@implementation {{$apiprefix}}{{$interface.Name}}{{.Name}}Params : NSObject
{{template "objc/properties_m" .Params}}
@end

// --- {{$apiprefix}}{{.Name}}Results ---
@implementation {{$apiprefix}}{{$interface.Name}}{{.Name}}Results : NSObject
{{template "objc/properties_m" .Results}}
@end
{{end}}{{end}}{{end}}

{{range .Interfaces}}{{$interface := .}}
@implementation {{$apiprefix}}{{.Name}} : NSObject
{{with .Constructor}}
{{template "objc/properties_m" .Method.Params}}
{{else}}
- (NSDictionary*) dictionary {
	return [NSDictionary dictionaryWithObjectsAndKeys:nil];
}
{{end}}
{{range .Methods}}{{$method := .}}
// --- {{.Name}} ---

- (void) {{.ParamsForObjcFunctionWithCallback $apiprefix $interface.Name}} {
	{{with .ConstructorForInterface}}
		{{$apiprefix}}{{.Name}} *results = [{{$apiprefix}}{{.Name}} alloc];
		{{range .Constructor.Method.Params}}
			{{$f := .ToLanguageField "objc"}}[results set{{$f.Name | title}}:{{$f.Name}}];
		{{end}}
	{{else}}
		// {{$apiprefix}}{{$interface.Name}}{{.Name}}Results *results = [{{$apiprefix}}{{$interface.Name}}{{.Name}}Results alloc];
		{{$apiprefix}}{{$interface.Name}}{{.Name}}Params *params = [[{{$apiprefix}}{{$interface.Name}}{{.Name}}Params alloc] init];
		{{range .Params}}{{$f := .ToLanguageField "objc"}}[params set{{$f.Name | title}}:{{$f.Name}}];
		{{end}}

		{{$apiprefix}}{{$pkgName}} * _api = [{{$apiprefix}}{{$pkgName}} get];
		NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/{{$interface.Name}}/{{.Name}}.json", [_api BaseURL]]];
		if([_api Verbose]) {
			NSLog(@"Requesting URL: %@", url);
		}

		[QXQortexapi request:url parameters:@{@"This": [self dictionary], @"Params": [params dictionary]} completionHandler:^(NSDictionary *data, NSError *error) {
			if (error && failureBlock) {
				if([_api Verbose]) {
					NSLog(@"Error: %@", error);
				}

				failureBlock(error);
			}

			if (successBlock) {
				{{$apiprefix}}{{$interface.Name}}{{.Name}}Results *results = [{{$apiprefix}}{{$interface.Name}}{{.Name}}Results alloc];
				results = [results initWithDictionary: data];
				successBlock(results{{$rLen := len .Results}}{{if eq $rLen 1}}.Err{{end}});
			}
		}];
	{{end}}
}
{{end}}@end
{{end}}
{{end}}
